---
page_title: 'Alphabetical List of Commands'
description: |-
  A list of all commands usable with Terraform in alphabetical order (this copy TBD)
---

# Alphabetical List of Commands

## add

The `terraform add` command generates a resource configuration template with
`null` placeholder values for all attributes, unless the `-from-state` flag is
used. By default, the template only includes required resource attributes; the
`-optional` flag tells Terraform to also include any optional attributes.

When `terraform add` used with the `-from-state` will _not_ print sensitive
values. You can use `terraform show ADDRESS` to see all values, including
sensitive values, recorded in state for the given resource address.

### Usage

Usage: `terraform add [options] ADDRESS`

This command requires an address that points to a resource which does not
already exist in the configuration. Addresses are in
[resource addressing format](/cli/state/resource-addressing).

This command accepts the following options:

`-from-state` - populate the template with values from a resource
already in state. Sensitive values are redacted.

`-optional` - include optional attributes in the template.

`-out=FILENAME` - writes the template to the given filename. If the file already
exists, the template will be added to the end of the file.

`-provider=provider` - override the configured provider for the resource. By
default, Terraform will use the configured provider for the given resource type,
and that is the best behavior in most cases.

## apply

> **Hands-on:** Try the [Terraform: Get Started](https://learn.hashicorp.com/collections/terraform/aws-get-started?utm_source=WEBSITE&utm_medium=WEB_IO&utm_offer=ARTICLE_PAGE&utm_content=DOCS) collection on HashiCorp Learn.

The `terraform apply` command is used to apply the changes required
to reach the desired state of the configuration, or the pre-determined
set of actions generated by a `terraform plan` execution plan.

### Usage

Usage: `terraform apply [options] [plan]`

By default, `apply` scans the current directory for the configuration
and applies the changes appropriately. However, you can optionally give the
path to a saved plan file that was previously created with
[`terraform plan`](plan).

If you don't give a plan file on the command line, `terraform apply` will
create a new plan automatically and then prompt for approval to apply it. If the
created plan does not include any changes to resources or to root module
output values then `terraform apply` will exit immediately, without prompting.

The command-line flags are all optional. The list of available flags are:

- `-backup=path` - Path to the backup file. Defaults to `-state-out` with
  the ".backup" extension. Disabled by setting to "-".

- `-compact-warnings` - If Terraform produces any warnings that are not
  accompanied by errors, show them in a more compact form that includes only
  the summary messages.

- `-lock=true` - Lock the state file when locking is supported.

- `-lock-timeout=0s` - Duration to retry a state lock.

- `-input=true` - Ask for input for variables if not directly set.

- `-auto-approve` - Skip interactive approval of plan before applying.

- `-no-color` - Disables output with coloring.

- `-parallelism=n` - Limit the number of concurrent operation as Terraform
  [walks the graph](/internals/graph#walking-the-graph). Defaults to 10.

- `-refresh=true` - Update the state for each resource prior to planning
  and applying. This has no effect if a plan file is given directly to
  apply.

- `-target=resource` - A [Resource
  Address](/cli/state/resource-addressing) to target. For more
  information, see
  [the targeting docs from `terraform plan`](/cli/commands/plan#resource-targeting).

- `-var 'foo=bar'` - Set a variable in the Terraform configuration. This flag
  can be set multiple times. Variable values are interpreted as
  [literal expressions](/language/expressions/types) in the
  Terraform language, so list and map values can be specified via this flag.

- `-var-file=foo` - Set variables in the Terraform configuration from
  a [variable file](/language/values/variables#variable-definitions-tfvars-files). If
  a `terraform.tfvars` or any `.auto.tfvars` files are present in the current
  directory, they will be automatically loaded. `terraform.tfvars` is loaded
  first and the `.auto.tfvars` files after in alphabetical order. Any files
  specified by `-var-file` override any values set automatically from files in
  the working directory. This flag can be used multiple times.

For configurations using
[the `local` backend](/language/settings/backends/enhanced/local) only,
`terraform apply` also accepts the legacy options
[`-state`, `-state-out`, and `-backup`](/language/settings/backends/enhanced/local#command-line-arguments).

### Passing a Different Configuration Directory

Terraform v0.13 and earlier also accepted a directory path in place of the
plan file argument to `terraform apply`, in which case Terraform would use
that directory as the root module instead of the current working directory.

That usage is still supported in Terraform v0.14, but is now deprecated and we
plan to remove it in Terraform v0.15. If your workflow relies on overriding
the root module directory, use
[the `-chdir` global option](/cli/commands/#switching-working-directory-with-chdir)
instead, which works across all commands and makes Terraform consistently look
in the given directory for all files it would normaly read or write in the
current working directory.

If your previous use of this legacy pattern was also relying on Terraform
writing the `.terraform` subdirectory into the current working directory even
though the root module directory was overridden, use
[the `TF_DATA_DIR` environment variable](/cli/config/environment-variables#tf_data_dir)
to direct Terraform to write the `.terraform` directory to a location other
than the current working directory.

## console

The `terraform console` command provides an interactive console for
evaluating [expressions](/language/expressions).

### Usage

Usage: `terraform console [options]`

This command provides an interactive command-line console for evaluating and
experimenting with [expressions](/language/expressions).
This is useful for testing interpolations before using them in configurations,
and for interacting with any values currently saved in
[state](/language/state).

If the current state is empty or has not yet been created, the console can be
used to experiment with the expression syntax and
[built-in functions](/language/functions).

You can close the console with the `exit` command or by pressing Control-C
or Control-D.

For configurations using
[the `local` backend](/language/settings/backends/enhanced/local) only,
`terraform console` accepts the legacy command line option
[`-state`](/language/settings/backends/enhanced/local#command-line-arguments).

### Scripting

The `terraform console` command can be used in non-interactive scripts
by piping newline-separated commands to it. Only the output from the
final command is printed unless an error occurs earlier.

For example:

```shell
$ echo "1 + 5" | terraform console
6
```

### Remote State

If [remote state](/language/state/remote) is used by the current backend,
Terraform will read the state for the current workspace from the backend
before evaluating any expressions.

## destroy

The `terraform destroy` command is used to destroy the Terraform-managed
infrastructure.

### Usage

Usage: `terraform destroy [options]`

Infrastructure managed by Terraform will be destroyed. This will ask for
confirmation before destroying.

This command accepts all the arguments and options that the [apply
command](/cli/commands/apply) accepts, with the exception of a plan file
argument.

If `-auto-approve` is set, then the destroy confirmation will not be shown.

The `-target` flag, instead of affecting "dependencies" will instead also
destroy any resources that _depend on_ the target(s) specified. For more information, see [the targeting docs from `terraform plan`](/cli/commands/plan#resource-targeting).

The behavior of any `terraform destroy` command can be previewed at any time
with an equivalent `terraform plan -destroy` command.

## env

The `terraform env` command is deprecated.
[The `terraform workspace` command](/cli/commands/workspace)
should be used instead.

## fmt

The `terraform fmt` command is used to rewrite Terraform configuration files
to a canonical format and style. This command applies a subset of
the [Terraform language style conventions](/language/syntax/style),
along with other minor adjustments for readability.

Other Terraform commands that generate Terraform configuration will produce
configuration files that conform to the style imposed by `terraform fmt`, so
using this style in your own files will ensure consistency.

The canonical format may change in minor ways between Terraform versions, so
after upgrading Terraform we recommend to proactively run `terraform fmt`
on your modules along with any other changes you are making to adopt the new
version.

We don't consider new formatting rules in `terraform fmt` to be a breaking
change in new versions of Terraform, but we do aim to minimize changes for
configurations that are already following the style examples shown in the
Terraform documentation. When adding new formatting rules, they will usually
aim to apply more of the rules already shown in the configuration examples
in the documentation, and so we recommend following the documented style even
for decisions that `terraform fmt` doesn't yet apply automatically.

Formatting decisions are always subjective and so you might disagree with the
decisions that `terraform fmt` makes. This command is intentionally opinionated
and has no customization options because its primary goal is to encourage
consistency of style between different Terraform codebases, even though the
chosen style can never be be everyone's favorite.

We recommend that you follow the style conventions applied by `terraform fmt`
when writing Terraform modules, but if you find the results particularly
objectionable then you may choose not to use this command, and possibly choose
to use a third-party formatting tool instead. If you choose to use a
third-party tool then you should also run it on files that are generated
automatically by Terraform, to get consistency between your hand-written files
and the generated files.

### Usage

Usage: `terraform fmt [options] [DIR]`

By default, `fmt` scans the current directory for configuration files. If
the `dir` argument is provided then it will scan that given directory
instead. If `dir` is a single dash (`-`) then `fmt` will read from standard
input (STDIN).

The command-line flags are all optional. The list of available flags are:

- `-list=false` - Don't list the files containing formatting inconsistencies.
- `-write=false` - Don't overwrite the input files. (This is implied by `-check` or when the input is STDIN.)
- `-diff` - Display diffs of formatting changes
- `-check` - Check if the input is formatted. Exit status will be 0 if
  all input is properly formatted and non-zero otherwise.
- `-recursive` - Also process files in subdirectories. By default, only the given directory (or current directory) is processed.

## force-unlock

Manually unlock the state for the defined configuration.

This will not modify your infrastructure. This command removes the lock on the
state for the current configuration. The behavior of this lock is dependent
on the backend being used. Local state files cannot be unlocked by another
process.

### Usage

Usage: `terraform force-unlock [options] LOCK_ID [DIR]`

Manually unlock the state for the defined configuration.

This will not modify your infrastructure. This command removes the lock on the
state for the current configuration. The behavior of this lock is dependent
on the backend being used. Local state files cannot be unlocked by another
process.

Options:

- `-force` - Don't ask for input for unlock confirmation.

## get

The `terraform get` command is used to download and update
[modules](/language/modules/develop) mentioned in the root module.

### Usage

Usage: `terraform get [options] PATH`

The modules are downloaded into a `.terraform` subdirectory of the current
working directory. Don't commit this directory to your version control
repository.

The `get` command supports the following option:

- `-update` - If specified, modules that are already downloaded will be
  checked for updates and the updates will be downloaded if present.

- `-no-color` - Disable text coloring in the output.

## graph

The `terraform graph` command is used to generate a visual
representation of either a configuration or execution plan.
The output is in the DOT format, which can be used by
[GraphViz](http://www.graphviz.org) to generate charts.

### Usage

Usage: `terraform graph [options]`

Outputs the visual execution graph of Terraform resources according to
either the current configuration or an execution plan.

The graph is outputted in DOT format. The typical program that can
read this format is GraphViz, but many web services are also available
to read this format.

The `-type` flag can be used to control the type of graph shown. Terraform
creates different graphs for different operations. See the options below
for the list of types supported. The default type is "plan" if a
configuration is given, and "apply" if a plan file is passed as an
argument.

Options:

- `-plan=tfplan` - Render graph using the specified plan file instead of the
  configuration in the current directory.

- `-draw-cycles` - Highlight any cycles in the graph with colored edges.
  This helps when diagnosing cycle errors.

- `-type=plan` - Type of graph to output. Can be: `plan`, `plan-destroy`, `apply`,
  `validate`, `input`, `refresh`.

- `-module-depth=n` - (deprecated) In prior versions of Terraform, specified the
  depth of modules to show in the output.

### Generating Images

The output of `terraform graph` is in the DOT format, which can
easily be converted to an image by making use of `dot` provided
by GraphViz:

```shellsession
$ terraform graph | dot -Tsvg > graph.svg
```

Here is an example graph output:
![Graph Example](/img/docs/graph-example.png)

## import

> **Hands-on:** Try the [Import Terraform Configuration](https://learn.hashicorp.com/tutorials/terraform/state-import?in=terraform/state&utm_source=WEBSITE&utm_medium=WEB_IO&utm_offer=ARTICLE_PAGE&utm_content=DOCS) tutorial on HashiCorp Learn.

The `terraform import` command is used to
[import existing resources](/cli/import)
into Terraform.

### Usage

Usage: `terraform import [options] ADDRESS ID`

Import will find the existing resource from ID and import it into your Terraform
state at the given ADDRESS.

ADDRESS must be a valid [resource address](/cli/state/resource-addressing).
Because any resource address is valid, the import command can import resources
into modules as well as directly into the root of your state.

ID is dependent on the resource type being imported. For example, for AWS
instances it is the instance ID (`i-abcd1234`) but for AWS Route53 zones
it is the zone ID (`Z12ABC4UGMOZ2N`). Please reference the provider documentation for details
on the ID format. If you're unsure, feel free to just try an ID. If the ID
is invalid, you'll just receive an error message.

~> Warning: Terraform expects that each remote object it is managing will be
bound to only one resource address, which is normally guaranteed by Terraform
itself having created all objects. If you import existing objects into Terraform,
be careful to import each remote object to only one Terraform resource address.
If you import the same object multiple times, Terraform may exhibit unwanted
behavior. For more information on this assumption, see
[the State section](/language/state).

The command-line flags are all optional. The list of available flags are:

- `-config=path` - Path to directory of Terraform configuration files that
  configure the provider for import. This defaults to your working directory.
  If this directory contains no Terraform configuration files, the provider
  must be configured via manual input or environmental variables.

- `-input=true` - Whether to ask for input for provider configuration.

- `-lock=true` - Lock the state file when locking is supported.

- `-lock-timeout=0s` - Duration to retry a state lock.

- `-no-color` - If specified, output won't contain any color.

- `-parallelism=n` - Limit the number of concurrent operation as Terraform
  [walks the graph](/internals/graph#walking-the-graph). Defaults
  to 10.

- `-provider=provider` - **Deprecated** Override the provider configuration to
  use when importing the object. By default, Terraform uses the provider specified
  in the configuration for the target resource, and that is the best behavior in most cases.

- `-var 'foo=bar'` - Set a variable in the Terraform configuration. This flag
  can be set multiple times. Variable values are interpreted as
  [literal expressions](/language/expressions/types) in the
  Terraform language, so list and map values can be specified via this flag.
  This is only useful with the `-config` flag.

- `-var-file=foo` - Set variables in the Terraform configuration from
  a [variable file](/language/values/variables#variable-definitions-tfvars-files). If
  a `terraform.tfvars` or any `.auto.tfvars` files are present in the current
  directory, they will be automatically loaded. `terraform.tfvars` is loaded
  first and the `.auto.tfvars` files after in alphabetical order. Any files
  specified by `-var-file` override any values set automatically from files in
  the working directory. This flag can be used multiple times. This is only
  useful with the `-config` flag.

- `-ignore-remote-version` - When using the enhanced remote backend with
  Terraform Cloud, continue even if remote and local Terraform versions differ.
  This may result in an unusable Terraform Cloud workspace, and should be used
  with extreme caution.

For configurations using
[the `local` backend](/language/settings/backends/enhanced/local) only,
`terraform import` also accepts the legacy options
[`-state`, `-state-out`, and `-backup`](/language/settings/backends/enhanced/local#command-line-arguments).

### Provider Configuration

Terraform will attempt to load configuration files that configure the
provider being used for import. If no configuration files are present or
no configuration for that specific provider is present, Terraform will
prompt you for access credentials. You may also specify environmental variables
to configure the provider.

The only limitation Terraform has when reading the configuration files
is that the import provider configurations must not depend on non-variable
inputs. For example, a provider configuration cannot depend on a data
source.

As a working example, if you're importing AWS resources and you have a
configuration file with the contents below, then Terraform will configure
the AWS provider with this file.

```hcl
variable "access_key" {}
variable "secret_key" {}

provider "aws" {
  access_key = "${var.access_key}"
  secret_key = "${var.secret_key}"
}
```

### Example: Import into Resource

This example will import an AWS instance into the `aws_instance` resource named `foo`:

```shell
$ terraform import aws_instance.foo i-abcd1234
```

### Example: Import into Module

The example below will import an AWS instance into the `aws_instance` resource named `bar` into a module named `foo`:

```shell
$ terraform import module.foo.aws_instance.bar i-abcd1234
```

### Example: Import into Resource configured with count

The example below will import an AWS instance into the first instance of the `aws_instance` resource named `baz` configured with
[`count`](/language/meta-arguments/count):

```shell
$ terraform import 'aws_instance.baz[0]' i-abcd1234
```

### Example: Import into Resource configured with for_each

The example below will import an AWS instance into the `"example"` instance of the `aws_instance` resource named `baz` configured with
[`for_each`](/language/meta-arguments/for_each):

Linux, Mac OS, and UNIX:

```shell
$ terraform import 'aws_instance.baz["example"]' i-abcd1234
```

PowerShell:

```shell
$ terraform import 'aws_instance.baz[\"example\"]' i-abcd1234
```

Windows `cmd.exe`:

```shell
$ terraform import aws_instance.baz[\"example\"] i-abcd1234
```

## init

> **Hands-on:** Try the [Terraform: Get Started](https://learn.hashicorp.com/collections/terraform/aws-get-started?utm_source=WEBSITE&utm_medium=WEB_IO&utm_offer=ARTICLE_PAGE&utm_content=DOCS) collection on HashiCorp Learn.

The `terraform init` command is used to initialize a working directory
containing Terraform configuration files. This is the first command that should
be run after writing a new Terraform configuration or cloning an existing one
from version control. It is safe to run this command multiple times.

### Usage

Usage: `terraform init [options]`

This command performs several different initialization steps in order to
prepare the current working directory for use with Terraform. More details on
these are in the sections below, but in most cases it is not necessary to worry
about these individual steps.

This command is always safe to run multiple times, to bring the working
directory up to date with changes in the configuration. Though subsequent runs
may give errors, this command will never delete your existing configuration or
state.

### General Options

The following options apply to all of (or several of) the initialization steps:

- `-input=true` Ask for input if necessary. If false, will error if
  input was required.

- `-lock=false` Disable locking of state files during state-related operations.

- `-lock-timeout=<duration>` Override the time Terraform will wait to acquire
  a state lock. The default is `0s` (zero seconds), which causes immediate
  failure if the lock is already held by another process.

- `-no-color` Disable color codes in the command output.

- `-upgrade` Opt to upgrade modules and plugins as part of their respective
  installation steps. See the sections below for more details.

### Copy a Source Module

By default, `terraform init` assumes that the working directory already
contains a configuration and will attempt to initialize that configuration.

Optionally, init can be run against an empty directory with the
`-from-module=MODULE-SOURCE` option, in which case the given module will be
copied into the target directory before any other initialization steps are
run.

This special mode of operation supports two use-cases:

- Given a version control source, it can serve as a shorthand for checking out
  a configuration from version control and then initializing the working directory
  for it.

- If the source refers to an _example_ configuration, it can be copied into
  a local directory to be used as a basis for a new configuration.

For routine use it is recommended to check out configuration from version
control separately, using the version control system's own commands. This way
it is possible to pass extra flags to the version control system when necessary,
and to perform other preparation steps (such as configuration generation, or
activating credentials) before running `terraform init`.

### Backend Initialization

During init, the root configuration directory is consulted for
[backend configuration](/language/settings/backends/configuration) and the chosen backend
is initialized using the given configuration settings.

Re-running init with an already-initialized backend will update the working
directory to use the new backend settings. Depending on what changed, this
may result in interactive prompts to confirm migration of workspace states.
The `-force-copy` option suppresses these prompts and answers "yes" to the
migration questions. The `-reconfigure` option disregards any existing
configuration, preventing migration of any existing state.

To skip backend configuration, use `-backend=false`. Note that some other init
steps require an initialized backend, so it is recommended to use this flag only
when the working directory was already previously initialized for a particular
backend.

The `-backend-config=...` option can be used for
[partial backend configuration](/language/settings/backends/configuration#partial-configuration),
in situations where the backend settings are dynamic or sensitive and so cannot
be statically specified in the configuration file.

### Child Module Installation

During init, the configuration is searched for `module` blocks, and the source
code for referenced [modules](/language/modules/develop) is retrieved from the locations
given in their `source` arguments.

Re-running init with modules already installed will install the sources for
any modules that were added to configuration since the last init, but will not
change any already-installed modules. Use `-upgrade` to override this behavior,
updating all modules to the latest available source code.

To skip child module installation, use `-get=false`. Note that some other init
steps can complete only when the module tree is complete, so it's recommended
to use this flag only when the working directory was already previously
initialized with its child modules.

### Plugin Installation

Most Terraform providers are published separately from Terraform as plugins.
During init, Terraform searches the configuration for both direct and indirect
references to providers and attempts to install the plugins for those providers.

For providers that are published in either
[the public Terraform Registry](https://registry.terraform.io/) or in a
third-party provider registry, `terraform init` will automatically find,
download, and install the necessary provider plugins. If you cannot or do not
wish to install providers from their origin registries, you can customize how
Terraform installs providers using
[the provider installation settings in the CLI configuration](/cli/config/config-file#provider-installation).

For more information about specifying which providers are required for each
of your modules, see [Provider Requirements](/language/providers/requirements).

After successful installation, Terraform writes information about the selected
providers to [the dependency lock file](/language/files/dependency-lock).
You should commit this file to your version control system to ensure that
when you run `terraform init` again in future Terraform will select exactly
the same provider versions. Use the `-upgrade` option if you want Terraform
to ignore the dependency lock file and consider installing newer versions.

You can modify `terraform init`'s plugin behavior with the following options:

- `-upgrade` Upgrade all previously-selected plugins to the newest version
  that complies with the configuration's version constraints. This will
  cause Terraform to ignore any selections recorded in the dependency lock
  file, and to take the newest available version matching the configured
  version constraints.
- `-get-plugins=false` — Skip plugin installation.

  -> Note: Since Terraform 0.13, this option has been superseded by the
  [`provider_installation`](/cli/config/config-file#provider-installation) and
  [`plugin_cache_dir`](/cli/config/config-file#plugin_cache_dir) settings.
  It should not be used in Terraform versions 0.13+, and this option
  was removed in Terraform 0.15.

- `-plugin-dir=PATH` — Force plugin installation to read plugins _only_ from
  the specified directory, as if it had been configured as a `filesystem_mirror`
  in the CLI configuration. If you intend to routinely use a particular
  filesystem mirror then we recommend
  [configuring Terraform's installation methods globally](/cli/config/config-file#provider-installation).
  You can use `-plugin-dir` as a one-time override for exceptional situations,
  such as if you are testing a local build of a provider plugin you are
  currently developing.
- `-lockfile=MODE` Set a dependency lockfile mode.

The valid values for the lockfile mode are as follows:

- readonly: suppress the lockfile changes, but verify checksums against the
  information already recorded. It conflicts with the `-upgrade` flag. If you
  update the lockfile with third-party dependency management tools, it would be
  useful to control when it changes explicitly.

### Running `terraform init` in automation

For teams that use Terraform as a key part of a change management and
deployment pipeline, it can be desirable to orchestrate Terraform runs in some
sort of automation in order to ensure consistency between runs, and provide
other interesting features such as integration with version control hooks.

There are some special concerns when running `init` in such an environment,
including optionally making plugins available locally to avoid repeated
re-installation. For more information, see
the [Running Terraform in Automation](https://learn.hashicorp.com/tutorials/terraform/automate-terraform?in=terraform/automation&utm_source=WEBSITE&utm_medium=WEB_IO&utm_offer=ARTICLE_PAGE&utm_content=DOCS) tutorial on HashiCorp Learn.

### Passing a Different Configuration Directory

Terraform v0.13 and earlier also accepted a directory path in place of the
plan file argument to `terraform apply`, in which case Terraform would use
that directory as the root module instead of the current working directory.

That usage is still supported in Terraform v0.14, but is now deprecated and we
plan to remove it in Terraform v0.15. If your workflow relies on overriding
the root module directory, use
[the `-chdir` global option](/cli/commands/#switching-working-directory-with-chdir)
instead, which works across all commands and makes Terraform consistently look
in the given directory for all files it would normaly read or write in the
current working directory.

If your previous use of this legacy pattern was also relying on Terraform
writing the `.terraform` subdirectory into the current working directory even
though the root module directory was overridden, use
[the `TF_DATA_DIR` environment variable](/cli/config/environment-variables#tf_data_dir)
to direct Terraform to write the `.terraform` directory to a location other
than the current working directory.

## login

The `terraform login` command can be used to automatically obtain and save an
API token for Terraform Cloud, Terraform Enterprise, or any other host that offers Terraform services.

-> **Note:** This command is suitable only for use in interactive scenarios
where it is possible to launch a web browser on the same host where Terraform
is running. If you are running Terraform in an unattended automation scenario,
you can
[configure credentials manually in the CLI configuration](/cli/config/config-file#credentials).

### Usage

Usage: `terraform login [hostname]`

If you don't provide an explicit hostname, Terraform will assume you want to
log in to Terraform Cloud at `app.terraform.io`.

### Credentials Storage

By default, Terraform will obtain an API token and save it in plain text in a
local CLI configuration file called `credentials.tfrc.json`. When you run
`terraform login`, it will explain specifically where it intends to save
the API token and give you a chance to cancel if the current configuration is
not as desired.

If you don't wish to store your API token in the default location, you can
optionally configure a
[credentials helper program](/cli/config/config-file#credentials-helpers) which knows
how to store and later retrieve credentials in some other system, such as
your organization's existing secrets management system.

### Login Server Support

The `terraform login` command works with any server supporting the
[login protocol](/internals/login-protocol), including Terraform Cloud
and Terraform Enterprise.

## logout

The `terraform logout` command is used to remove credentials stored by
`terraform login`. These credentials are API tokens for Terraform Cloud,
Terraform Enterprise, or any other host that offers Terraform services.

### Usage

Usage: `terraform logout [hostname]`

If you don't provide an explicit hostname, Terraform will assume you want to
log out of Terraform Cloud at `app.terraform.io`.

-> **Note:** the API token is only removed from local storage, not destroyed on
the remote server, so it will remain valid until manually revoked.

### Credentials Storage

By default, Terraform will remove the token stored in plain text in a local CLI
configuration file called `credentials.tfrc.json`. If you have configured a
[credentials helper program](/cli/config/config-file#credentials-helpers), Terraform
will use the helper's `forget` command to remove it.

## output

The `terraform output` command is used to extract the value of
an output variable from the state file.

### Usage

Usage: `terraform output [options] [NAME]`

With no additional arguments, `output` will display all the outputs for
the root module. If an output `NAME` is specified, only the value of that
output is printed.

The command-line flags are all optional. The list of available flags are:

- `-json` - If specified, the outputs are formatted as a JSON object, with
  a key per output. If `NAME` is specified, only the output specified will be
  returned. This can be piped into tools such as `jq` for further processing.
- `-raw` - If specified, Terraform will convert the specified output value to a
  string and print that string directly to the output, without any special
  formatting. This can be convenient when working with shell scripts, but
  it only supports string, number, and boolean values. Use `-json` instead
  for processing complex data types.
- `-no-color` - If specified, output won't contain any color.
- `-state=path` - Path to the state file. Defaults to "terraform.tfstate".
  Ignored when [remote state](/language/state/remote) is used.

### Examples

These examples assume the following Terraform output snippet.

```hcl
output "instance_ips" {
  value = aws_instance.web.*.public_ip
}

output "lb_address" {
  value = aws_alb.web.public_dns
}

output "password" {
  sensitive = true
  value = var.secret_password
}
```

To list all outputs:

```shellsession
$ terraform output
instance_ips = [
  "54.43.114.12",
  "52.122.13.4",
  "52.4.116.53"
]
lb_address = "my-app-alb-1657023003.us-east-1.elb.amazonaws.com"
password = <sensitive>
```

Note that outputs with the `sensitive` attribute will be redacted:

```shellsession
$ terraform output password
password = <sensitive>
```

To query for the DNS address of the load balancer:

```shellsession
$ terraform output lb_address
"my-app-alb-1657023003.us-east-1.elb.amazonaws.com"
```

To query for all instance IP addresses:

```shellsession
$ terraform output instance_ips
instance_ips = [
  "54.43.114.12",
  "52.122.13.4",
  "52.4.116.53"
]
```

### Use in automation

The `terraform output` command by default displays in a human-readable format,
which can change over time to improve clarity.

For scripting and automation, use `-json` to produce the stable JSON format.
You can parse the output using a JSON command-line parser such as
[jq](https://stedolan.github.io/jq/):

```shellsession
$ terraform output -json instance_ips | jq -r '.[0]'
54.43.114.12
```

For the common case of directly using a string value in a shell script, you
can use `-raw` instead, which will print the string directly with no extra
escaping or whitespace.

```shellsession
$ terraform output -raw lb_address
my-app-alb-1657023003.us-east-1.elb.amazonaws.com
```

The `-raw` option works only with values that Terraform can automatically
convert to strings. Use `-json` instead, possibly combined with `jq`, to
work with complex-typed values such as objects.

Terraform strings are sequences of Unicode characters rather than raw bytes,
so the `-raw` output will be UTF-8 encoded when it contains non-ASCII
characters. If you need a different character encoding, use a separate command
such as `iconv` to transcode Terraform's raw output.

## plan

> **Hands-on:** Try the [Terraform: Get Started](https://learn.hashicorp.com/collections/terraform/aws-get-started?utm_source=WEBSITE&utm_medium=WEB_IO&utm_offer=ARTICLE_PAGE&utm_content=DOCS) collection on HashiCorp Learn.

The `terraform plan` command is used to create an execution plan. Terraform
performs a refresh, unless explicitly disabled, and then determines what
actions are necessary to achieve the desired state specified in the
configuration files.

This command is a convenient way to check whether the execution plan for a
set of changes matches your expectations without making any changes to
real resources or to the state. For example, `terraform plan` might be run
before committing a change to version control, to create confidence that it
will behave as expected.

The optional `-out` argument can be used to save the generated plan to a file
for later execution with `terraform apply`, which can be useful when
[running Terraform in automation](https://learn.hashicorp.com/tutorials/terraform/automate-terraform?in=terraform/automation&utm_source=WEBSITE&utm_medium=WEB_IO&utm_offer=ARTICLE_PAGE&utm_content=DOCS).

If Terraform detects no changes to resource or to root module output values,
`terraform plan` will indicate that no changes are required.

### Usage

Usage: `terraform plan [options]`

The `plan` subcommand looks in the current working directory for the root module
configuration.

The available options are:

- `-compact-warnings` - If Terraform produces any warnings that are not
  accompanied by errors, show them in a more compact form that includes only
  the summary messages.

- `-destroy` - If set, generates a plan to destroy all the known resources.

- `-detailed-exitcode` - Return a detailed exit code when the command exits.
  When provided, this argument changes the exit codes and their meanings to
  provide more granular information about what the resulting plan contains:

  - 0 = Succeeded with empty diff (no changes)
  - 1 = Error
  - 2 = Succeeded with non-empty diff (changes present)

- `-input=true` - Ask for input for variables if not directly set.

- `-lock=true` - Lock the state file when locking is supported.

- `-lock-timeout=0s` - Duration to retry a state lock.

- `-no-color` - Disables output with coloring.

- `-out=path` - The path to save the generated execution plan. This plan
  can then be used with `terraform apply` to be certain that only the
  changes shown in this plan are applied. Read the warning on saved
  plans below.

- `-parallelism=n` - Limit the number of concurrent operation as Terraform
  [walks the graph](/internals/graph#walking-the-graph). Defaults
  to 10.

- `-refresh=true` - Update the state prior to checking for differences.

- `-target=resource` - A [Resource
  Address](/cli/state/resource-addressing) to target. This flag can
  be used multiple times. See below for more information.

- `-var 'foo=bar'` - Set a variable in the Terraform configuration. This flag
  can be set multiple times. Variable values are interpreted as
  [literal expressions](/language/expressions/types) in the
  Terraform language, so list and map values can be specified via this flag.

- `-var-file=foo` - Set variables in the Terraform configuration from
  a [variable file](/language/values/variables#variable-definitions-tfvars-files). If
  a `terraform.tfvars` or any `.auto.tfvars` files are present in the current
  directory, they will be automatically loaded. `terraform.tfvars` is loaded
  first and the `.auto.tfvars` files after in alphabetical order. Any files
  specified by `-var-file` override any values set automatically from files in
  the working directory. This flag can be used multiple times.

For configurations using
[the `local` backend](/language/settings/backends/enhanced/local) only,
`terraform plan` accepts the legacy command line option
[`-state`](/language/settings/backends/enhanced/local#command-line-arguments).

### Resource Targeting

> **Hands-on:** Try the [Target resources](https://learn.hashicorp.com/tutorials/terraform/resource-targeting?in=terraform/state&utm_source=WEBSITE&utm_medium=WEB_IO&utm_offer=ARTICLE_PAGE&utm_content=DOCS) tutorial on HashiCorp Learn.

The `-target` option can be used to focus Terraform's attention on only a
subset of resources.
[Resource Address](/cli/state/resource-addressing) syntax is used
to specify the constraint. The resource address is interpreted as follows:

- If the given address has a _resource spec_, only the specified resource
  is targeted. If the named resource uses `count` and no explicit index
  is specified in the address (i.e. aws_instance.example[3]), all of the instances sharing the given
  resource name are targeted.

- If the given address _does not_ have a resource spec, and instead just
  specifies a module path, the target applies to all resources in the
  specified module _and_ all of the descendent modules of the specified
  module.

This targeting capability is provided for exceptional circumstances, such
as recovering from mistakes or working around Terraform limitations. It
is _not recommended_ to use `-target` for routine operations, since this can
lead to undetected configuration drift and confusion about how the true state
of resources relates to configuration.

Instead of using `-target` as a means to operate on isolated portions of very
large configurations, prefer instead to break large configurations into
several smaller configurations that can each be independently applied.
[Data sources](/language/data-sources) can be used to access
information about resources created in other configurations, allowing
a complex system architecture to be broken down into more manageable parts
that can be updated independently.

### Security Warning

Saved plan files (with the `-out` flag) encode the configuration,
state, diff, and _variables_. Variables are often used to store secrets.
Therefore, the plan file can potentially store secrets.

Terraform itself does not encrypt the plan file. It is highly
recommended to encrypt the plan file if you intend to transfer it
or keep it at rest for an extended period of time.

Future versions of Terraform will make plan files more
secure.

### Passing a Different Configuration Directory

Terraform v0.13 and earlier accepted an additional positional argument giving
a directory path, in which case Terraform would use that directory as the root
module instead of the current working directory.

That usage is still supported in Terraform v0.14, but is now deprecated and we
plan to remove it in Terraform v0.15. If your workflow relies on overriding
the root module directory, use
[the `-chdir` global option](/cli/commands/#switching-working-directory-with-chdir)
instead, which works across all commands and makes Terraform consistently look
in the given directory for all files it would normaly read or write in the
current working directory.

If your previous use of this legacy pattern was also relying on Terraform
writing the `.terraform` subdirectory into the current working directory even
though the root module directory was overridden, use
[the `TF_DATA_DIR` environment variable](/cli/config/environment-variables#tf_data_dir)
to direct Terraform to write the `.terraform` directory to a location other
than the current working directory.

## terraform providers lock

The `terraform providers lock` consults upstream registries (by default) in
order to write provider dependency information into
[the dependency lock file](/language/files/dependency-lock).

The common way to update the dependency lock file is as a side-effect of normal
provider installation during
[`terraform init`](/cli/commands/init), but there are several situations where that
automatic approach may not be sufficient:

- If you are running Terraform in an environment that uses
  [alternative provider installation methods](/cli/config/config-file#provider-installation),
  such as filesystem or network mirrors, normal provider installation will not
  access the origin registry for a provider and therefore Terraform will not
  be able to populate all of the possible package checksums for the selected
  provider versions.

  If you use `terraform lock` to write the official release checksums for a
  provider into the dependency lock file then future `terraform init` runs
  will verify the packages available in your selected mirror against the
  official checksums previously recorded, giving additional certainty that
  the mirror is serving the provider packages it is claiming to.

- If your team runs Terraform across a number of different platforms (e.g.
  on both Windows and Linux) and the upstream registry for a provider is unable
  to provide signed checksums using the latest hashing scheme, subsequent runs
  of Terraform on other platforms may
  [add additional checksums to the lock file](/language/files/dependency-lock#new-provider-package-checksums).
  You can avoid that by pre-populating hashes for all of the platforms you
  intend to use, using the `terraform providers lock` command.

-> `terraform providers lock` is available only in Terraform v0.14 or later.

### Usage

Usage: `terraform providers lock [options] [providers...]`

With no additional command line arguments, `terraform providers lock` will
analyze the configuration in the current working directory to find all of
the providers it depends on, and it will fetch the necessary data about those
providers from their origin registries and then update
[the dependency lock file](/language/files/dependency-lock) to
include a selected version for each provider and all of the package checksums
that are covered by the provider developer's cryptographic signature.

~> **Warning:** The `terraform providers lock` command prints information
about what it has fetched and whether each package was signed using a
cryptographic signature, but it cannot automatically verify that the
providers are trustworthy and that they comply with your local system
policies or relevant regulations. Review the signing key information
in the output to confirm that you trust all of the signers before committing
the updated lock file to your version control system.

If you list one or more provider source addresses on the command line then
`terraform providers lock` will restrict its work only to those providers,
leaving the lock entries for other providers (if any) unchanged.

You can customize the default behavior using the following additional option:

- `-fs-mirror=PATH` - Direct Terraform to look for provider packages in the
  given local filesystem mirror directory, instead of in upstream registries.
  The given directory must use the usual filesystem mirror directory layout.

- `-net-mirror=URL` - Direct Terraform to look for provider packages in the
  given network mirror service, instead of in upstream registries. The
  given URL must implement
  [the Terraform provider network mirror protocol](/internals/provider-network-mirror-protocol).

- `-platform=OS_ARCH` - Specify a platform you intend to use to work with this
  Terraform configuration. Terraform will ensure that the providers are all
  available for the given platform and will save enough package checksums in
  the lock file to support _at least_ the specified platforms.

  Use this option multiple times to include checksums for multiple target
  systems.

  Target platform names consist of an operating system and a CPU
  architecture. For example, `linux_amd64` selects the Linux operating system
  running on an AMD64 or x86_64 CPU.

  There is more detail on this option in the following section.

### Specifying Target Platforms

In your environment you may, for example, have both developers who work with
your Terraform configuration on their Windows or macOS workstations _and_
automated systems that apply the configuration while running on Linux.

In that situation, you could choose to verify that all of your providers support
all of those platforms, and to pre-populate the lock file with the necessary
checksums, by running `terraform providers lock` and specifying those three
platforms:

```
terraform providers lock \
  -platform=windows_amd64 \ # 64-bit Windows
  -platform=darwin_amd64 \  # 64-bit macOS
  -platform=linux_amd64     # 64-bit Linux
```

(The above example uses Unix-style shell wrapping syntax for readability. If
you are running the command on Windows then you will need to put all of the
arguments on a single line, and remove the backslashes and comments.)

### Lock Entries for In-house Providers

An _in-house provider_ is one that isn't published on a real Terraform provider
registry because it's developed and used only within a particular organization and
distributed via either a filesystem mirror or network mirror.

By default, `terraform providers lock` assumes all providers are available
at a Terraform provider registry and tries to contact the origin registries
in order to get access to the most detailed information about the provider
packages.

To create a lock entry for a particular provider that is available only in a
local mirror, you can use either the `-fs-mirror` or `-net-mirror` command
line options to override the default behavior of consulting the provider's
origin registry:

```
terraform providers lock \
  -fs-mirror=/usr/local/terraform/providers
  -platform=windows_amd64 \
  -platform=darwin_amd64 \
  -platform=linux_amd64 \
  tf.example.com/ourcompany/ourplatform
```

(The above example uses Unix-style shell wrapping syntax for readability. If
you are running the command on Windows then you will need to put all of the
arguments on a single line, and remove the backslashes.)

Because the command above includes the provider source address
`tf.example.com/ourcompany/ourplatform`, `terraform providers lock` will only
attempt to access that particular provider and will leave the lock entries
for any other providers unchanged. If you have a variety of different providers
available from different sources, you can run `terraform providers lock`
multiple times and specify a different subset of your providers each time.

The `-fs-mirror` and `-net-mirror` options have the same meaning as
`filesystem_mirror` and `network_mirror` blocks in
[the provider installation methods configuration](/cli/config/config-file#provider-installation),
but specify only a single method in order to be explicit about where you
intend to derive the package checksum information from.

Note that only an origin registry can provide official checksums covered by
the original developer's cryptographic signature. Lock entries created from
filesystem or network mirrors will therefore cover only the exact platforms
you requested, and the recorded checksums will be those reported by the
mirror, rather than the origin registry's official checksums. If you want
to ensure that the recorded checksums are the ones signed by the original
provider publisher, run this command _without_ either the `-fs-mirror` or
`-net-mirror` options to fetch all information from origin registries.

If you wish, you can publish your in-house providers via an in-house provider
registry, which will then allow locking and installation of those providers
without any special options or additional CLI configuration. For more
information, see
[the provider registry protocol](/internals/provider-registry-protocol).

## terraform providers mirror

The `terraform providers mirror` command downloads the providers required
for the current configuration and copies them into a directory in the local
filesystem.

In normal use, `terraform init` will automatically download needed providers
from provider registries as part of initializing the current working directory.
Sometimes Terraform is running in an environment where that isn't possible,
such as on an isolated network without access to the Terraform Registry. In
that case,
[explicit installation method configuration](/cli/config/config-file#explicit-installation-method-configuration)
allows you to configure Terraform, when running on a particular system, to
consult only a local filesystem directory where you've created a local mirror
of the necessary plugins, and to skip accessing the upstream registry at all.

The `terraform providers mirror` command can automatically populate a directory
that will be used as a local filesystem mirror in the provider installation
configuration.

-> `terraform providers mirror` is available only in Terraform v0.13 or later.

### Usage

Usage: `terraform providers mirror [options] <target-dir>`

A single target directory is required. Terraform will create under that
directory the path structure that is expected for filesystem-based provider
plugin mirrors, populating it with `.zip` files containing the plugins
themselves.

Terraform will also generate various `.json` index files which contain suitable
responses to implement
[the network mirror protocol](/internals/provider-network-mirror-protocol),
if you upload the resulting directory to a static website host. Terraform
ignores those index files when using the directory as a filesystem mirror,
because the directory entries themselves are authoritative in that case.

This command supports the following additional option:

- `-platform=OS_ARCH` - Choose which target platform to build a mirror for.
  By default Terraform will obtain plugin packages suitable for the platform
  where you run this command. Use this flag multiple times to include packages
  for multiple target systems.

  Target platform names consist of an operating system and a CPU
  architecture. For example, `linux_amd64` selects the Linux operating system
  running on an AMD64 or x86_64 CPU.

You can run `terraform providers mirror` again on an existing mirror directory
to update it with new packages. For example, you can add packages for a new
target platform by re-running the command with the desired new `-platform=...`
option, and it will place the packages for that new platform without removing
packages you previously downloaded, merging the resulting set of packages
together to update the JSON index files.

## terraform providers schema

The `terraform providers schema` command is used to print detailed schemas for the providers used in the current configuration.

-> `terraform providers schema` requires **Terraform v0.12 or later**.

### Usage

Usage: `terraform providers schema [options]`

The list of available flags are:

- `-json` - Displays the schemas in a machine-readable, JSON format.

Please note that, at this time, the `-json` flag is a _required_ option. In future releases, this command will be extended to allow for additional options.

-> **Note:** The output includes a `format_version` key, which currently has major version zero to indicate that the format is experimental and subject to change. A future version will assign a non-zero major version and make stronger promises about compatibility. We do not anticipate any significant breaking changes to the format before its first major version, however.

### Format Summary

The following sections describe the JSON output format by example, using a pseudo-JSON notation.
Important elements are described with comments, which are prefixed with //.
To avoid excessive repetition, we've split the complete format into several discrete sub-objects, described under separate headers. References wrapped in angle brackets (like `<block-representation>`) are placeholders which, in the real output, would be replaced by an instance of the specified sub-object.

The JSON output format consists of the following objects and sub-objects:

- [Providers Schema Representation](#providers-schema-representation) - the top-level object returned by `terraform providers schema -json`
- [Schema Representation](#schema-representation) - a sub-object of providers, resources, and data sources that describes their schema
- [Block Representation](#block-representation) - a sub-object of schemas that describes attributes and nested blocks

### Providers Schema Representation

```javascript
{
  "format_version": "0.1",

  // "provider_schemas" describes the provider schemas for all
  // providers throughout the configuration tree.
  "provider_schemas": {
    // keys in this map are the provider type, such as "random"
    "example_provider_name": {
      // "provider" is the schema for the provider configuration
      "provider": <schema-representation>,

      // "resource_schemas" map the resource type name to the resource's schema
      "resource_schemas": {
        "example_resource_name": <schema-representation>
      },

      // "data_source_schemas" map the data source type name to the
      // data source's schema
      "data_source_schemas": {
        "example_datasource_name": <schema-representation>,
      }
    },
    "example_provider_two": { … }
  }
}
```

### Schema Representation

A schema representation pairs a provider or resource schema (in a "block") with that schema's version.

```javascript
{
  // "version" is the schema version, not the provider version
  "version": int64,
  "block": <block-representation>
}
```

### Block Representation

A block representation contains "attributes" and "block_types" (which represent nested blocks).

```javascript
{
  // "attributes" describes any attributes that appear directly inside the
  // block. Keys in this map are the attribute names.
  "attributes":  {
    "example_attribute_name": {
      // "type" is a representation of a type specification
      // that the attribute's value must conform to.
      "type": "string",

      // "description" is an English-language description of
      // the purpose and usage of the attribute.
      "description": "string",

      // "required", if set to true, specifies that an
      // omitted or null value is not permitted.
      "required": bool,

      // "optional", if set to true, specifies that an
      // omitted or null value is permitted.
      "optional": bool,

      // "computed", if set to true, indicates that the
      // value comes from the provider rather than the
      // configuration.
      "computed": bool,

      // "sensitive", if set to true, indicates that the
      // attribute may contain sensitive information.
      "sensitive": bool
    },
  },
  // "block_types" describes any nested blocks that appear directly
  // inside the block.
  // Keys in this map are the names of the block_type.
  "block_types": {
    "example_block_name": {
      // "nesting_mode" describes the nesting mode for the
      // child block, and can be one of the following:
      // 	single
      // 	list
      // 	set
      // 	map
    "nesting_mode": "list",
    "block": <block-representation>,

    // "min_items" and "max_items" set lower and upper
    // limits on the number of child blocks allowed for
    // the list and set modes. These are
    // omitted for other modes.
    "min_items": 1,
    "max_items": 3
  }
}
```

## push

!> **Important:** The `terraform push` command is no longer functional. Its functionality was replaced and surpassed by [the `remote` backend](/language/settings/backends/enhanced/remote), which works with current versions of Terraform Cloud. The `remote` backend allows you to run remote operations directly from the command line, and displays real-time output from the remote run environment.

The `terraform push` command was an early implementation of remote Terraform runs. It allowed teams to push a configuration to a remote run environment in a discontinued version of Terraform Enterprise.

The legacy Terraform Enterprise version that supported `terraform push` is no longer available, and there are no remaining instances of that version in operation. Without a service to push to, the command is now completely non-functional.

## refresh

The `terraform refresh` command is used to reconcile the state Terraform
knows about (via its state file) with the real-world infrastructure.
This can be used to detect any drift from the last-known state, and to
update the state file.

This does not modify infrastructure, but does modify the state file.
If the state is changed, this may cause changes to occur during the next
plan or apply.

### Usage

Usage: `terraform refresh [options]`

The `terraform refresh` command accepts the following options:

- `-compact-warnings` - If Terraform produces any warnings that are not
  accompanied by errors, show them in a more compact form that includes only
  the summary messages.

- `-input=true` - Ask for input for variables if not directly set.

- `-lock=true` - Lock the state file when locking is supported.

- `-lock-timeout=0s` - Duration to retry a state lock.

- `-no-color` - If specified, output won't contain any color.

- `-parallelism=n` - Limit the number of concurrent operation as Terraform
  [walks the graph](/internals/graph#walking-the-graph). Defaults
  to 10.

- `-target=resource` - A [Resource
  Address](/cli/state/resource-addressing) to target. Operation will
  be limited to this resource and its dependencies. This flag can be used
  multiple times.

- `-var 'foo=bar'` - Set a variable in the Terraform configuration. This flag
  can be set multiple times. Variable values are interpreted as
  [literal expressions](/language/expressions/types) in the
  Terraform language, so list and map values can be specified via this flag.

- `-var-file=foo` - Set variables in the Terraform configuration from
  a [variable file](/language/values/variables#variable-definitions-tfvars-files). If
  a `terraform.tfvars` or any `.auto.tfvars` files are present in the current
  directory, they will be automatically loaded. `terraform.tfvars` is loaded
  first and the `.auto.tfvars` files after in alphabetical order. Any files
  specified by `-var-file` override any values set automatically from files in
  the working directory. This flag can be used multiple times.
  For configurations using
  [the `local` backend](/language/settings/backends/enhanced/local) only,
  `terraform refresh` also accepts the legacy options
  [`-state`, `-state-out`, and `-backup`](/language/settings/backends/enhanced/local#command-line-arguments).

## show

The `terraform show` command is used to provide human-readable output
from a state or plan file. This can be used to inspect a plan to ensure
that the planned operations are expected, or to inspect the current state
as Terraform sees it.

Machine-readable output is generated by adding the `-json` command-line
flag.

-> **Note:** When using the `-json` command-line flag, any sensitive values in
Terraform state will be displayed in plain text. For more information, see
[Sensitive Data in State](/language/state/sensitive-data).

### JSON Output

For Terraform state files (including when no path is provided),
`terraform show -json` will show a JSON representation of the state.

For Terraform plan files, `terraform show -json` will show a JSON representation
of the plan, configuration, and current state.

If you've updated providers which contain new schema versions since the state
was written, the state needs to be upgraded before it can be displayed with
`show -json`. If you are viewing a plan, it must be created without
`-refresh=false`. If you are viewing a state file, run `terraform refresh`
first.

The output format is covered in detail in [JSON Output Format](/internals/json-format).

### Usage

Usage: `terraform show [options] [file]`

You may use `show` with a path to either a Terraform state file or plan
file. If you don't specify a file path, Terraform will show the latest state
snapshot.

This command accepts the following options:

- `-no-color` - Disables output with coloring

- `-json` - Displays machine-readable output from a state or plan file

-> JSON output via the `-json` option requires **Terraform v0.12 or later**.

## state list

The `terraform state list` command is used to list resources within a
[Terraform state](/language/state).

### Usage

Usage: `terraform state list [options] [address...]`

The command will list all resources in the state file matching the given
addresses (if any). If no addresses are given, all resources are listed.

The resources listed are sorted according to module depth order followed
by alphabetical. This means that resources that are in your immediate
configuration are listed first, and resources that are more deeply nested
within modules are listed last.

For complex infrastructures, the state can contain thousands of resources.
To filter these, provide one or more patterns to the command. Patterns are
in [resource addressing format](/cli/state/resource-addressing).

The command-line flags are all optional. The list of available flags are:

- `-state=path` - Path to the state file. Defaults to "terraform.tfstate".
  Ignored when [remote state](/language/state/remote) is used.
- `-id=id` - ID of resources to show. Ignored when unset.

### Example: All Resources

This example will list all resources, including modules:

```
$ terraform state list
aws_instance.foo
aws_instance.bar[0]
aws_instance.bar[1]
module.elb.aws_elb.main
```

### Example: Filtering by Resource

This example will only list resources for the given name:

```
$ terraform state list aws_instance.bar
aws_instance.bar[0]
aws_instance.bar[1]
```

### Example: Filtering by Module

This example will list resources in the given module and any submodules:

```
$ terraform state list module.elb
module.elb.aws_elb.main
module.elb.module.secgroups.aws_security_group.sg
```

### Example: Filtering by ID

This example will only list the resource whose ID is specified on the
command line. This is useful to find where in your configuration a
specific resource is located.

```
$ terraform state list -id=sg-1234abcd
module.elb.aws_security_group.sg
```

## state mv

The `terraform state mv` command is used to move items in a
[Terraform state](/language/state). This command can move
single resources, single instances of a resource, entire modules, and more.
This command can also move items to a completely different state file,
enabling efficient refactoring.

### Usage

Usage: `terraform state mv [options] SOURCE DESTINATION`

This command will move an item matched by the address given to the
destination address. This command can also move to a destination address
in a completely different state file.

This can be used for simple resource renaming, moving items to and from
a module, moving entire modules, and more. And because this command can also
move data to a completely new state, it can also be used for refactoring
one configuration into multiple separately managed Terraform configurations.

This command will output a backup copy of the state prior to saving any
changes. The backup cannot be disabled. Due to the destructive nature
of this command, backups are required.

If you're moving an item to a different state file, a backup will be created
for each state file.

This command requires a source and destination address of the item to move.
Addresses are
in [resource addressing format](/cli/state/resource-addressing).

The command-line flags are all optional. The list of available flags are:

- `-backup=path` - Path where Terraform should write the backup for the
  original state. This can't be disabled. If not set, Terraform will write it
  to the same path as the statefile with a ".backup" extension.

- `-backup-out=path` - Path where Terraform should write the backup for the
  destination state. This can't be disabled. If not set, Terraform will write
  it to the same path as the destination state file with a backup extension.
  This only needs to be specified if -state-out is set to a different path than
  -state.

- `-state=path` - Path to the source state file to read from. Defaults to the
  configured backend, or "terraform.tfstate".

- `-state-out=path` - Path to the destination state file to write to. If this
  isn't specified the source state file will be used. This can be a new or
  existing path.

- `-ignore-remote-version` - When using the enhanced remote backend with
  Terraform Cloud, continue even if remote and local Terraform versions differ.
  This may result in an unusable Terraform Cloud workspace, and should be used
  with extreme caution.

### Example: Rename a Resource

The example below renames the `packet_device` resource named `worker` to `helper`:

```shell
$ terraform state mv 'packet_device.worker' 'packet_device.helper'
```

### Example: Move a Resource Into a Module

The example below moves the `packet_device` resource named `worker` into a module
named `app`. The module will be created if it doesn't exist.

```shell
$ terraform state mv 'packet_device.worker' 'module.app.packet_device.worker'
```

### Example: Move a Module Into a Module

The example below moves the module named `app` under the module named `parent`.

```shell
$ terraform state mv 'module.app' 'module.parent.module.app'
```

### Example: Move a Module to Another State

The example below moves the module named `app` into another state file. This removes
the module from the original state file and adds it to the destination.
The source and destination are the same meaning we're keeping the same name.

```shell
$ terraform state mv -state-out=other.tfstate 'module.app' 'module.app'
```

### Example: Move a Resource configured with count

The example below moves the first instance of a `packet_device` resource named `worker` configured with
[`count`](/language/meta-arguments/count) to
the first instance of a resource named `helper` also configured with `count`:

```shell
$ terraform state mv 'packet_device.worker[0]' 'packet_device.helper[0]'
```

### Example: Move a Resource configured with for_each

The example below moves the `"example123"` instance of a `packet_device` resource named `worker` configured with
[`for_each`](/language/meta-arguments/for_each)
to the `"example456"` instance of a resource named `helper` also configuring `for_each`:

Linux, Mac OS, and UNIX:

```shell
$ terraform state mv 'packet_device.worker["example123"]' 'packet_device.helper["example456"]'
```

PowerShell:

```shell
$ terraform state mv 'packet_device.worker[\"example123\"]' 'packet_device.helper[\"example456\"]'
```

Windows `cmd.exe`:

```shell
$ terraform state mv packet_device.worker[\"example123\"] packet_device.helper[\"example456\"]
```

## state pull

The `terraform state pull` command is used to manually download and output
the state from [remote state](/language/state/remote). This command also
works with local state.

### Usage

Usage: `terraform state pull`

This command will download the state from its current location, upgrade the
local copy to the latest state file version that is compatible with
locally-installed Terraform, and output the raw format to stdout.

This is useful for reading values out of state (potentially pairing this
command with something like [jq](https://stedolan.github.io/jq/)). It is
also useful if you need to make manual modifications to state.

~> Note: This command cannot be used to inspect the Terraform version of
the remote state, as it will always be converted to the current Terraform
version before output.

## state push

The `terraform state push` command is used to manually upload a local
state file to [remote state](/language/state/remote). This command also
works with local state.

This command should rarely be used. It is meant only as a utility in case
manual intervention is necessary with the remote state.

### Usage

Usage: `terraform state push [options] PATH`

This command will push the state specified by PATH to the currently
configured [backend](/language/settings/backends).

If PATH is "-" then the state data to push is read from stdin. This data
is loaded completely into memory and verified prior to being written to
the destination state.

Terraform will perform a number of safety checks to prevent you from
making changes that appear to be unsafe:

- **Differing lineage**: If the "lineage" value in the state differs,
  Terraform will not allow you to push the state. A differing lineage
  suggests that the states are completely different and you may lose
  data.

- **Higher remote serial**: If the "serial" value in the destination state
  is higher than the state being pushed, Terraform will prevent the push.
  A higher serial suggests that data is in the destination state that isn't
  accounted for in the local state being pushed.

Both of these safety checks can be disabled with the `-force` flag.
**This is not recommended.** If you disable the safety checks and are
pushing state, the destination state will be overwritten.

Other available flags:

- `-ignore-remote-version` - When using the enhanced remote backend with
  Terraform Cloud, continue even if remote and local Terraform versions differ.
  This may result in an unusable Terraform Cloud workspace, and should be used
  with extreme caution.

## state replace-provider

The `terraform state replace-provider` command is used to replace the provider
for resources in a [Terraform state](/language/state).

### Usage

Usage: `terraform state replace-provider [options] FROM_PROVIDER_FQN TO_PROVIDER_FQN`

This command will update all resources using the "from" provider, setting the
provider to the specified "to" provider. This allows changing the source of a
provider which currently has resources in state.

This command will output a backup copy of the state prior to saving any
changes. The backup cannot be disabled. Due to the destructive nature
of this command, backups are required.

The command-line flags are all optional. The list of available flags are:

- `-auto-approve` - Skip interactive approval.

- `-backup=path` - Path where Terraform should write the backup for the
  original state. This can't be disabled. If not set, Terraform will write it
  to the same path as the statefile with a ".backup" extension.

- `-lock=true`- Lock the state files when locking is supported.

- `-lock-timeout=0s` - Duration to retry a state lock.

- `-state=path` - Path to the source state file to read from. Defaults to the
  configured backend, or "terraform.tfstate".

- `-ignore-remote-version` - When using the enhanced remote backend with
  Terraform Cloud, continue even if remote and local Terraform versions differ.
  This may result in an unusable Terraform Cloud workspace, and should be used
  with extreme caution.

### Example

The example below replaces the `hashicorp/aws` provider with a fork by `acme`, hosted at a private registry at `registry.acme.corp`:

```shell
$ terraform state replace-provider hashicorp/aws registry.acme.corp/acme/aws
```

## state rm

The `terraform state rm` command is used to remove items from the
[Terraform state](/language/state). This command can remove
single resources, single instances of a resource, entire modules,
and more.

### Usage

Usage: `terraform state rm [options] ADDRESS...`

Remove one or more items from the Terraform state.

Items removed from the Terraform state are _not physically destroyed_.
Items removed from the Terraform state are only no longer managed by
Terraform. For example, if you remove an AWS instance from the state, the AWS
instance will continue running, but `terraform plan` will no longer see that
instance.

There are various use cases for removing items from a Terraform state
file. The most common is refactoring a configuration to no longer manage
that resource (perhaps moving it to another Terraform configuration/state).

The state will only be saved on successful removal of all addresses.
If any specific address errors for any reason (such as a syntax error),
the state will not be modified at all.

This command will output a backup copy of the state prior to saving any
changes. The backup cannot be disabled. Due to the destructive nature
of this command, backups are required.

This command requires one or more addresses that point to a resources in the
state. Addresses are
in [resource addressing format](/cli/state/resource-addressing).

The command-line flags are all optional. The list of available flags are:

- `-backup=path` - Path where Terraform should write the backup state. This
  can't be disabled. If not set, Terraform will write it to the same path as
  the statefile with a backup extension.

- `-state=path` - Path to a Terraform state file to use to look up
  Terraform-managed resources. By default it will use the configured backend,
  or the default "terraform.tfstate" if it exists.

- `-ignore-remote-version` - When using the enhanced remote backend with
  Terraform Cloud, continue even if remote and local Terraform versions differ.
  This may result in an unusable Terraform Cloud workspace, and should be used
  with extreme caution.

### Example: Remove a Resource

The example below removes the `packet_device` resource named `worker`:

```shell
$ terraform state rm 'packet_device.worker'
```

### Example: Remove a Module

The example below removes the entire module named `foo`:

```shell
$ terraform state rm 'module.foo'
```

### Example: Remove a Module Resource

The example below removes the `packet_device` resource named `worker` inside a module named `foo`:

```shell
$ terraform state rm 'module.foo.packet_device.worker'
```

### Example: Remove a Resource configured with count

The example below removes the first instance of a `packet_device` resource named `worker` configured with
[`count`](/language/meta-arguments/count):

```shell
$ terraform state rm 'packet_device.worker[0]'
```

### Example: Remove a Resource configured with for_each

The example below removes the `"example"` instance of a `packet_device` resource named `worker` configured with
[`for_each`](/language/meta-arguments/for_each):

Linux, Mac OS, and UNIX:

```shell
$ terraform state rm 'packet_device.worker["example"]'
```

PowerShell:

```shell
$ terraform state rm 'packet_device.worker[\"example\"]'
```

Windows `cmd.exe`:

```shell
$ terraform state rm packet_device.worker[\"example\"]
```

## state show

The `terraform state show` command is used to show the attributes of a
single resource in the
[Terraform state](/language/state).

### Usage

Usage: `terraform state show [options] ADDRESS`

The command will show the attributes of a single resource in the
state file that matches the given address.

This command requires an address that points to a single resource in the
state. Addresses are
in [resource addressing format](/cli/state/resource-addressing).

The command-line flags are all optional. The list of available flags are:

- `-state=path` - Path to the state file. Defaults to "terraform.tfstate".
  Ignored when [remote state](/language/state/remote) is used.

The output of `terraform state show` is intended for human consumption, not
programmatic consumption. To extract state data for use in other software, use
[`terraform show -json`](/cli/commands/show#json-output) and decode the result
using the documented structure.

### Example: Show a Resource

The example below shows a `packet_device` resource named `worker`:

```
$ terraform state show 'packet_device.worker'
# packet_device.worker:
resource "packet_device" "worker" {
    billing_cycle = "hourly"
    created       = "2015-12-17T00:06:56Z"
    facility      = "ewr1"
    hostname      = "prod-xyz01"
    id            = "6015bg2b-b8c4-4925-aad2-f0671d5d3b13"
    locked        = false
}
```

### Example: Show a Module Resource

The example below shows a `packet_device` resource named `worker` inside a module named `foo`:

```shell
$ terraform state show 'module.foo.packet_device.worker'
```

### Example: Show a Resource configured with count

The example below shows the first instance of a `packet_device` resource named `worker` configured with
[`count`](/language/meta-arguments/count):

```shell
$ terraform state show 'packet_device.worker[0]'
```

### Example: Show a Resource configured with for_each

The example below shows the `"example"` instance of a `packet_device` resource named `worker` configured with
[`for_each`](/language/meta-arguments/for_each):

Linux, Mac OS, and UNIX:

```shell
$ terraform state show 'packet_device.worker["example"]'
```

PowerShell:

```shell
$ terraform state show 'packet_device.worker[\"example\"]'
```

Windows `cmd.exe`:

```shell
$ terraform state show packet_device.worker[\"example\"]
```

## taint

The `terraform taint` command manually marks a Terraform-managed resource
as tainted, forcing it to be destroyed and recreated on the next apply.

This command _will not_ modify infrastructure, but does modify the
state file in order to mark a resource as tainted. Once a resource is
marked as tainted, the next
[plan](/cli/commands/plan) will show that the resource will
be destroyed and recreated and the next
[apply](/cli/commands/apply) will implement this change.

Forcing the recreation of a resource is useful when you want a certain
side effect of recreation that is not visible in the attributes of a resource.
For example: re-running provisioners will cause the node to be different
or rebooting the machine from a base image will cause new startup scripts
to run.

Note that tainting a resource for recreation may affect resources that
depend on the newly tainted resource. For example, a DNS resource that
uses the IP address of a server may need to be modified to reflect
the potentially new IP address of a tainted server. The
[plan command](/cli/commands/plan) will show this if this is
the case.

### Usage

Usage: `terraform taint [options] address`

The `address` argument is the address of the resource to mark as tainted.
The address is in
[the resource address syntax](/cli/state/resource-addressing) syntax,
as shown in the output from other commands, such as:

- `aws_instance.foo`
- `aws_instance.bar[1]`
- ` aws_instance.baz``[\"key\"] ` (quotes in resource addresses must be escaped on the command line, so that they are not interpreted by your shell)
- `module.foo.module.bar.aws_instance.qux`

The command-line flags are all optional. The list of available flags are:

- `-allow-missing` - If specified, the command will succeed (exit code 0)
  even if the resource is missing. The command can still error, but only
  in critically erroneous cases.

- `-backup=path` - Path to the backup file. Defaults to `-state-out` with
  the ".backup" extension. Disabled by setting to "-".

- `-lock=true` - Lock the state file when locking is supported.

- `-lock-timeout=0s` - Duration to retry a state lock.

- `-state=path` - Path to read and write the state file to. Defaults to "terraform.tfstate".
  Ignored when [remote state](/language/state/remote) is used.

- `-state-out=path` - Path to write updated state file. By default, the
  `-state` path will be used. Ignored when
  [remote state](/language/state/remote) is used.

- `-ignore-remote-version` - When using the enhanced remote backend with
  Terraform Cloud, continue even if remote and local Terraform versions differ.
  This may result in an unusable Terraform Cloud workspace, and should be used
  with extreme caution.

### Example: Tainting a Single Resource

This example will taint a single resource:

```
$ terraform taint aws_security_group.allow_all
The resource aws_security_group.allow_all in the module root has been marked as tainted.
```

### Example: Tainting a single resource created with for_each

This example will taint a single resource created with for_each:

```
$ terraform taint 'module.route_tables.azurerm_route_table.rt["DefaultSubnet"]'
The resource module.route_tables.azurerm_route_table.rt["DefaultSubnet"] in the module root has been marked as tainted.
```

~> Note: In most `sh` compatible shells, double quotes and spaces can be
escaped by wrapping the argument in single quotes. This however varies between
other shells and operating systems, and users should use the appropriate escape
characters based on the applicable quoting rules for their shell to pass the
address string, including quotes, to Terraform.

### Example: Tainting a Resource within a Module

This example will only taint a resource within a module:

```
$ terraform taint "module.couchbase.aws_instance.cb_node[9]"
Resource instance module.couchbase.aws_instance.cb_node[9] has been marked as tainted.
```

Although we recommend that most configurations use only one level of nesting
and employ [module composition](/language/modules/develop/composition), it's possible
to have multiple levels of nested modules. In that case the resource instance
address must include all of the steps to the target instance, as in the
following example:

```
$ terraform taint "module.child.module.grandchild.aws_instance.example[2]"
Resource instance module.child.module.grandchild.aws_instance.example[2] has been marked as tainted.
```

## test

The `terraform test` command is currently serving as part of
[the module integration testing experiment](/language/modules/testing-experiment).

It's not ready for routine use, but if you'd be interested in trying the
prototype functionality then we'd love to hear your feedback. See the
experiment details page linked above for more information.

## untaint

The `terraform untaint` command manually unmarks a Terraform-managed resource
as tainted, restoring it as the primary instance in the state. This reverses
either a manual `terraform taint` or the result of provisioners failing on a
resource.

This command _will not_ modify infrastructure, but does modify the state file
in order to unmark a resource as tainted.

~> **NOTE on Tainted Indexes:** In certain edge cases, more than one tainted
instance can be present for a single resource. When this happens, you need to specify the index after the resources, e.g. `my-resource-example[2]`. You can use the `terraform show` command to inspect the state and
determine which index holds the instance you'd like to restore. In the vast
majority of cases, there will only be one tainted instance, and the `-index`
flag can be omitted.

### Usage

Usage: `terraform untaint [options] name`

The `name` argument is the name of the resource to mark as untainted. The
format of this argument is `TYPE.NAME`, such as `aws_instance.foo`.

The command-line flags are all optional (with the exception of `-index` in
certain cases, see above note). The list of available flags are:

- `-allow-missing` - If specified, the command will succeed (exit code 0)
  even if the resource is missing. The command can still error, but only
  in critically erroneous cases.

- `-backup=path` - Path to the backup file. Defaults to `-state-out` with
  the ".backup" extension. Disabled by setting to "-".

- `-lock=true` - Lock the state file when locking is supported.

- `-lock-timeout=0s` - Duration to retry a state lock.

- `-no-color` - Disables output with coloring

- `-state=path` - Path to read and write the state file to. Defaults to "terraform.tfstate".
  Ignored when [remote state](/language/state/remote) is used.

- `-state-out=path` - Path to write updated state file. By default, the
  `-state` path will be used. Ignored when
  [remote state](/language/state/remote) is used.

- `-ignore-remote-version` - When using the enhanced remote backend with
  Terraform Cloud, continue even if remote and local Terraform versions differ.
  This may result in an unusable Terraform Cloud workspace, and should be used
  with extreme caution.

## validate

The `terraform validate` command validates the configuration files in a
directory, referring only to the configuration and not accessing any remote
services such as remote state, provider APIs, etc.

Validate runs checks that verify whether a configuration is syntactically
valid and internally consistent, regardless of any provided variables or
existing state. It is thus primarily useful for general verification of
reusable modules, including correctness of attribute names and value types.

It is safe to run this command automatically, for example as a post-save
check in a text editor or as a test step for a re-usable module in a CI
system.

Validation requires an initialized working directory with any referenced
plugins and modules installed. To initialize a working directory for
validation without accessing any configured remote backend, use:

```
$ terraform init -backend=false
```

To verify configuration in the context of a particular run (a particular
target workspace, input variable values, etc), use the `terraform plan`
command instead, which includes an implied validation check.

### Usage

Usage: `terraform validate [options]`

This command accepts the following options:

- `-json` - Produce output in a machine-readable JSON format, suitable for
  use in text editor integrations and other automated systems. Always disables
  color.

- `-no-color` - If specified, output won't contain any color.

### JSON Output Format

When you use the `-json` option, Terraform will produce validation results
in JSON format to allow using the validation result for tool integrations, such
as highlighting errors in a text editor.

As with all JSON output options, it's possible that Terraform will encounter
an error prior to beginning the validation task that will thus not be subject
to the JSON output setting. For that reason, external software consuming
Terraform's output should be prepared to find data on stdout that _isn't_ valid
JSON, which it should then treat as a generic error case.

**Note:** The output includes a `format_version` key, which currently has major
version zero to indicate that the format is experimental and subject to change.
A future version will assign a non-zero major version and make stronger
promises about compatibility. We do not anticipate any significant breaking
changes to the format before its first major version, however.

In the normal case, Terraform will print a JSON object to the standard output
stream. The top-level JSON object will have the following properties:

- `valid` (boolean): Summarizes the overall validation result, by indicating
  `true` if Terraform considers the current configuration to be valid or
  `false` if it detected any errors.

- `error_count` (number): A zero or positive whole number giving the count
  of errors Terraform detected. If `valid` is `false` then `error_count` will
  always be zero, because it is the presence of errors that indicates that
  a configuration is invalid.

- `warning_count` (number): A zero or positive whole number giving the count
  of warnings Terraform detected. Warnings do not cause Terraform to consider
  a configuration to be invalid, but they do indicate potential caveats that
  a user should consider and possibly resolve.

- `diagnostics` (array of objects): A JSON array of nested objects that each
  describe an error or warning from Terraform.

The nested objects in `diagnostics` have the following properties:

- `severity` (string): A string keyword, currently either `"error"` or
  `"warning"`, indicating the diagnostic severity.

  The presence of errors causes Terraform to consider a configuration to be
  invalid, while warnings are just advice or caveats to the user which do not
  block working with the configuration. Later versions of Terraform may
  introduce new severity keywords, so consumers should be prepared to accept
  and ignore severity values they don't understand.

- `summary` (string): A short description of the nature of the problem that
  the diagnostic is reporting.

  In Terraform's usual human-oriented diagnostic messages, the summary serves
  as a sort of "heading" for the diagnostic, printed after the "Error:" or
  "Warning:" indicator.

  Summaries are typically short, single sentences, but can sometimes be longer
  as a result of returning errors from subsystems that are not designed to
  return full diagnostics, where the entire error message therefore becomes the
  summary. In those cases, the summary might include newline characters which
  a renderer should honor when presenting the message visually to a user.

- `detail` (string): An optional additional message giving more detail about
  the problem.

  In Terraform's usual human-oriented diagnostic messages, the detail provides
  the paragraphs of text that appear after the heading and the source location
  reference.

  Detail messages are often multiple paragraphs and possibly interspersed with
  non-paragraph lines, so tools which aim to present detail messages to the
  user should distinguish between lines without leading spaces, treating them
  as paragraphs, and lines with leading spaces, treating them as preformatted
  text. Renderers should then soft-wrap the paragraphs to fit the width of the
  rendering container, but leave the preformatted lines unwrapped.

  Some Terraform detail messages currently contain an approximation of bullet
  lists using ASCII characters to mark the bullets. This is not currently a
  contractural formatting convention and so renderers should avoid depending on
  it and should instead treat those lines as either paragraphs or preformatted
  text per the rules above. A future version of this format may define some
  additional rules for processing other text conventions, but will do so within
  the bounds of the rules above to achieve backward-compatibility.

- `range` (object): An optional object referencing a portion of the configuration
  source code that the diagnostic message relates to. For errors, this will
  typically indicate the bounds of the specific block header, attribute, or
  expression which was detected as invalid.

  A source range is an object with a property `filename` which gives the
  filename as a relative path from the current working directory, and then
  two properties `start` and `end` which are both themselves objects
  describing source positions, as described below.

  Not all diagnostic messages are connected with specific portions of the
  configuration, so `range` will be omitted or `null` for diagnostic messages
  where it isn't relevant.

- `snippet` (object): An optional object including an excerpt of the
  configuration source code that the diagnostic message relates to.

  The snippet information includes:

  - `context` (string): An optional summary of the root context of the
    diagnostic. For example, this might be the resource block containing the
    expression which triggered the diagnostic. For some diagnostics this
    information is not available, and then this property will be `null`.

  - `code` (string): A snippet of Terraform configuration including the
    source of the diagnostic. This can be multiple lines and may include
    additional configuration source code around the expression which
    triggered the diagnostic.

  - `start_line` (number): A one-based line count representing the position
    in the source file at which the `code` excerpt begins. This is not
    necessarily the same value as `range.start.line`, as it is possible for
    `code` to include one or more lines of context before the source of the
    diagnostic.

  - `highlight_start_offset` (number): A zero-based character offset into the
    `code` string, pointing at the start of the expression which triggered
    the diagnostic.

  - `highlight_end_offset` (number): A zero-based character offset into the
    `code` string, pointing at the end of the expression which triggered the
    diagnostic.

  - `values` (array of objects): Contains zero or more expression values
    which may be useful in understanding the source of a diagnostic in a
    complex expression. These expression value objects are described below.

#### Source Position

A source position object, as used in the `range` property of a diagnostic
object, has the following properties:

- `byte` (number): A zero-based byte offset into the indicated file.

- `line` (number): A one-based line count for the line containing the relevant
  position in the indicated file.

- `column` (number): A one-based count of _Unicode characters_ from the start
  of the line indicated in `line`.

A `start` position is inclusive while an `end` position is exclusive. The
exact positions used for particular error messages are intended for human
interpretation only and subject to change in future versions of Terraform due
either to improvements to the error reporting or changes in implementation
details of the language parser/evaluator.

#### Expression Value

An expression value object gives additional information about a value which is
part of the expression which triggered the diagnostic. This is especially
useful when using `for_each` or similar constructs, in order to identify
exactly which values are responsible for an error. The object has two properties:

- `traversal` (string): An HCL-like traversal string, such as
  `var.instance_count`. Complex index key values may be elided, so this will
  not always be valid, parseable HCL. The contents of this string are intended
  to be human-readable and are subject to change in future versions of
  Terraform.

- `statement` (string): A short English-language fragment describing the value
  of the expression when the diagnostic was triggered. The contents of this
  string are intended to be human-readable and are subject to change in future
  versions of Terraform.

## version

The `terraform version` displays the current version of Terraform and all
installed plugins.

### Usage

Usage: `terraform version [options]`

With no additional arguments, `version` will display the version of Terraform,
the platform it's installed on, installed providers, and the results of upgrade
and security checks [unless disabled](/cli/commands#upgrade-and-security-bulletin-checks).

This command has one optional flag:

- `-json` - If specified, the version information is formatted as a JSON object,
  and no upgrade or security information is included.

-> **Note:** Platform information was added to the `version` command in Terraform 0.15.

### Example

Basic usage, with upgrade and security information shown if relevant:

```shellsession
$ terraform version
Terraform v0.15.0
on darwin_amd64
+ provider registry.terraform.io/hashicorp/null v3.0.0

Your version of Terraform is out of date! The latest version
is X.Y.Z. You can update by downloading from https://www.terraform.io/downloads
```

As JSON:

```shellsession
$ terraform version -json
{
  "terraform_version": "0.15.0",
  "platform": "darwin_amd64",
  "provider_selections": {
    "registry.terraform.io/hashicorp/null": "3.0.0"
  },
  "terraform_outdated": true
}
```

## workspace delete

The `terraform workspace delete` command is used to delete an existing workspace.

### Usage

Usage: `terraform workspace delete [OPTIONS] NAME [DIR]`

This command will delete the specified workspace.

To delete an workspace, it must already exist, it must have an empty state,
and it must not be your current workspace. If the workspace state is not empty,
Terraform will not allow you to delete it unless the `-force` flag is specified.

If you delete a workspace with a non-empty state (via `-force`), then resources
may become "dangling". These are resources that physically exist but that
Terraform can no longer manage. This is sometimes preferred: you want
Terraform to stop managing resources so they can be managed some other way.
Most of the time, however, this is not intended and so Terraform protects you
from getting into this situation.

The command-line flags are all optional. The only supported flag is:

- `-force` - Delete the workspace even if its state is not empty. Defaults to false.
- `-lock` - Lock the state file when locking is supported. Defaults to true.
- `-lock-timeout` - Duration to retry a state lock. Default 0s.

### Example

```
$ terraform workspace delete example
Deleted workspace "example".
```

## workspace list

The `terraform workspace list` command is used to list all existing workspaces.

### Usage

Usage: `terraform workspace list [DIR]`

The command will list all existing workspaces. The current workspace is
indicated using an asterisk (`*`) marker.

### Example

```
$ terraform workspace list
  default
* development
  jsmith-test
```

## workspace new

The `terraform workspace new` command is used to create a new workspace.

### Usage

Usage: `terraform workspace new [OPTIONS] NAME [DIR]`

This command will create a new workspace with the given name. A workspace with
this name must not already exist.

If the `-state` flag is given, the state specified by the given path
will be copied to initialize the state for this new workspace.

The command-line flags are all optional. The supported flags are:

- `-lock` - Lock the state file when locking is supported. Defaults to true.
- `-lock-timeout` - Duration to retry a state lock. Default 0s.
- `-state=path` - Path to an existing state file to initialize the state of this environment.

### Example: Create

```
$ terraform workspace new example
Created and switched to workspace "example"!

You're now on a new, empty workspace. Workspaces isolate their state,
so if you run "terraform plan" Terraform will not see any existing state
for this configuration.
```

### Example: Create from State

To create a new workspace from a pre-existing local state file:

```
$ terraform workspace new -state=old.terraform.tfstate example
Created and switched to workspace "example".

You're now on a new, empty workspace. Workspaces isolate their state,
so if you run "terraform plan" Terraform will not see any existing state
for this configuration.
```

## workspace select

The `terraform workspace select` command is used to choose a different
workspace to use for further operations.

### Usage

Usage: `terraform workspace select NAME [DIR]`

This command will select another workspace. The named workspace must already
exist.

### Example

```
$ terraform workspace list
  default
* development
  jsmith-test

$ terraform workspace select default
Switched to workspace "default".
```

## workspace show

The `terraform workspace show` command is used to output the current workspace.

### Usage

Usage: `terraform workspace show`

The command will display the current workspace.

### Example

```
$ terraform workspace show
development
```

## 0.12upgrade

The `terraform 0.12upgrade` command applies several automatic upgrade rules to
help prepare a module that was written for Terraform v0.11 to be used
with Terraform v0.12.

-> **This command is available only in Terraform v0.12 releases.** For more information, see [the Terraform v0.12 upgrade guide](/language/upgrade-guides/0-12).

### Usage

Usage: `terraform 0.12upgrade [options] [dir]`

By default, `0.12upgrade` changes configuration files in the current working
directory. However, you can provide an explicit path to another directory if
desired, which may be useful for automating migrations of several modules in
the same repository.

When run with no other options, the command will first explain what it is
going to do and prompt for confirmation:

```
$ terraform 0.12upgrade

This command will rewrite the configuration files in the given directory so
that they use the new syntax features from Terraform v0.12, and will identify
any constructs that may need to be adjusted for correct operation with
Terraform v0.12.

We recommend using this command in a clean version control work tree, so that
you can easily see the proposed changes as a diff against the latest commit.
If you have uncommitted changes already present, we recommend aborting this
command and dealing with them before running this command again.

Would you like to upgrade the module in the current directory?
  Only 'yes' will be accepted to confirm.

  Enter a value: yes
```

The `0.12upgrade` subcommand requires access to providers used in the
configuration in order to analyze their resource types, so it's important to
run `terraform init` first to install these. In some rare cases, a configuration
that worked in v0.11 may have syntax errors in v0.12, in which case
`terraform init` will run in a special mode where it installs only enough to
run the upgrade command, after which you can run `terraform init` again to
complete initialization.

Many of the rewrite rules are completely automatic, but in some cases the
tool cannot determine enough information from the configuration alone to make
a decision, and so it will instead add a comment to the configuration for
user review. All such comments contain the string `TF-UPGRADE-TODO` to make
them easier to find.

After upgrading, the configuration will also be reformatted into the standard
Terraform style and expressions rewritten to use the more-readable v0.12 syntax
features.

We recommend running this command with a clean version control work tree so
that you can use VCS tools to review the proposed changes, including any
`TF-UPGRADE-TODO` comments, and make any revisions required before committing
the change.

Once upgraded the configuration will no longer be compatible with Terraform
v0.11 and earlier. When upgrading a shared module that is called from multiple
configurations, you may need to
[fix existing configurations to a previous version](/language/modules/syntax#version)
to allow for a gradual upgrade. If the module is published via
[a Terraform registry](/registry/), assign a new _major_ version number
to the upgraded module source to represent the fact that this is a breaking
change for v0.11 callers. If a module is installed directly from a version
control system such as Git,
[use specific revisions](/language/modules/sources#selecting-a-revision)
to control which version is used by which caller.

The command-line options are all optional. The available options are:

- `-yes` - Skip the initial introduction messages and interactive confirmation.
  Use this when running the command in batch from a script.

- `-force` - Override the heuristic that attempts to detect if a configuration
  is already written for v0.12 or later. Some of the transformations made by
  this command are not idempotent, so re-running against the same module may
  change the meanings of some expressions in the module.

### Batch Usage

After you've experimented with the `0.12upgrade` command in some confined
situations, if you have a repository containing multiple modules you may
wish to batch-upgrade them all and review them together. Recursive upgrades
are not supported by the tool itself, but if you are on a Unix-style system
you can achieve this using the `find` command as follows:

```
find . -name '*.tf' -printf "%h\n" | uniq | xargs -n1 terraform 0.12upgrade -yes
```

On Mac OS X, the `find` included with the system does not support the `-printf` argument. You can install GNU find using Homebrew in order to use that argument:

```
brew install findutils
```

Once installed, run the above command line using `gfind` instead of `find`.

Note that the above includes the `-yes` option to override the interactive
prompt, so be sure you have a clean work tree before running it.

Because upgrading requires access to the configuration's provider plugins,
all of the directories must be initialized with `terraform init` prior to
running the above.

## 0.13upgrade

The `terraform 0.13upgrade` command updates existing configuration to add an
explicit `source` attribute for each provider used in a given module. The
provider source settings are stored in a `required_providers` block.

-> **This command is available only in Terraform v0.13 releases.** For more information, see [the Terraform v0.13 upgrade guide](/language/upgrade-guides/0-13).

### Usage

Usage: `terraform 0.13upgrade [options] [dir]`

The primary purpose of the `0.13upgrade` command is to determine which
providers are in use for a module, detect the source address for those
providers where possible, and record this information in a
[`required_providers` block][required-providers].

[required-providers]: /language/providers/requirements

~> Note: the command ignores `.tf.json` files and override files in the module.

If the module already has a `required_providers` block, the command updates it
in-place. Otherwise, a new block is added to the `versions.tf` file.

By default, `0.13upgrade` changes configuration files in the current working
directory. However, you can provide an explicit path to another directory if
desired, which may be useful for automating migrations of several modules in
the same repository.

When run with no other options, the command will first explain what it is
going to do and prompt for confirmation:

```
$ terraform 0.13upgrade

This command will update the configuration files in the given directory to use
the new provider source features from Terraform v0.13. It will also highlight
any providers for which the source cannot be detected, and advise how to
proceed.

We recommend using this command in a clean version control work tree, so that
you can easily see the proposed changes as a diff against the latest commit.
If you have uncommited changes already present, we recommend aborting this
command and dealing with them before running this command again.

Would you like to upgrade the module in the current directory?
  Only 'yes' will be accepted to confirm.

  Enter a value: yes
```

We recommend running this command with a clean version control work tree so
that you can use VCS tools to review the proposed changes, including any
`TF-UPGRADE-TODO` comments, and make any revisions required before committing
the change.

There is one command-line option:

- `-yes` - Skip the initial introduction messages and interactive confirmation.
  Use this when running the command in batch from a script.

### Batch Usage

After you've experimented with the `0.13upgrade` command in some confined
situations, if you have a repository containing multiple modules you may
wish to batch-upgrade them all and review them together. Recursive upgrades
are not supported by the tool itself, but if you are on a Unix-style system
you can achieve this using the `find` command as follows:

```
$ find . -name '*.tf' | xargs -n1 dirname | uniq | xargs -n1 terraform 0.13upgrade -yes
```

On a Windows system with PowerShell, you can use this command:

```
Get-Childitem -Recurse -Include *.tf | Split-Path | `
Select-Object -Unique | ForEach-Object { terraform 0.13upgrade -yes $_.FullName }
```

Note that the above commands include the `-yes` option to override the
interactive prompt, so be sure you have a clean work tree before running it.
